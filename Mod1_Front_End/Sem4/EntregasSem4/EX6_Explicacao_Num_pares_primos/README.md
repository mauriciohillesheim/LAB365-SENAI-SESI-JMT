### Primos ###

Primeiramente, foi criada uma função auxiliar essencial chamada ehPrimo(num). O propósito desta função é determinar, de forma eficiente, se um único número num fornecido como argumento é primo ou não. A função começa tratando casos base: números menores ou iguais a 1 não são primos, então retorna false. Os números 2 e 3 são primos, então retorna true imediatamente para eles. Em seguida, aplica-se uma otimização inicial: se o número for divisível por 2 ou por 3 (verificado através do operador módulo %), ele não pode ser primo (exceto os próprios 2 e 3, já tratados), então a função retorna false. Isso elimina rapidamente uma grande quantidade de números compostos.
Para os números restantes, a função utiliza um laço for otimizado para verificar possíveis divisores. A verificação começa a partir de 5 e progride em incrementos de 6 (i = i + 6). Essa estratégia é eficaz porque todos os números primos maiores que 3 podem ser expressos na forma 6k ± 1 (onde k é um inteiro). Portanto, dentro do laço, verificamos se num é divisível por i (que terá a forma 6k - 1 ou 6k + 5) ou por i + 2 (que terá a forma 6k + 1). O laço continua apenas enquanto i * i <= num. Isso se baseia no princípio de que, se um número num tem um divisor maior que sua raiz quadrada, ele necessariamente também terá um divisor menor que sua raiz quadrada. Portanto, só precisamos testar divisores até a raiz quadrada de num para determinar sua primalidade. Se nenhum divisor for encontrado dentro do laço, o número passou por todas as verificações e é considerado primo, fazendo a função retornar true.
Com a função ehPrimo definida, foi criada a função encontrarPrimos(limite). Esta função é responsável por iterar através dos números, começando do 2 (o primeiro número primo) até o limite fornecido pelo usuário. Para cada numeroAtual dentro deste intervalo, a função encontrarPrimos chama a função auxiliar ehPrimo(numeroAtual). Se ehPrimo retornar true, significa que numeroAtual é um número primo, e ele é então adicionado a um array chamado primosEncontrados.
Ao final da iteração, quando todos os números de 2 até limite foram verificados, a função encontrarPrimos retorna o array primosEncontrados, que contém a lista completa de todos os números primos identificados dentro do intervalo especificado.
Finalmente, a função principal calcular() foi modificada para utilizar essas novas funções. Após validar a entrada do usuário, ela chama encontrarPrimos(numero) para obter a lista de primos e armazena o resultado na variável primos. Os resultados (tanto os pares quanto os primos, cada um obtido por sua respectiva função) são então formatados e exibidos na resultadoDiv da página HTML, mostrando a quantidade encontrada e a lista de números para cada categoria (pares e primos) separadamente.


### Pares ###

 O primeiro passo dentro da função calcular() é obter a referência a dois elementos HTML importantes: um campo de entrada (input) com o ID numeroInput e um elemento de divisão (div) com o ID resultado. O campo numeroInput é onde o usuário digita o número limite para a busca, enquanto a resultadoDiv é a área onde os resultados da operação serão exibidos na página web.
Em seguida, o valor digitado pelo usuário no campo de entrada é lido e armazenado na variável input. O código utiliza a função parseInt() para converter esse valor, que inicialmente é uma string, em um número inteiro, armazenando-o na variável numero. Uma verificação crucial é realizada logo após: a função isNaN() checa se o valor resultante da conversão não é um número (Not a Number), e também se verifica se o número é menor que 1. Caso qualquer uma dessas condições seja verdadeira, significa que o usuário inseriu um valor inválido (texto, vazio ou um número não positivo). Nesse cenário, uma mensagem de erro é exibida dentro da resultadoDiv, instruindo o usuário a digitar um número válido maior que zero, e a execução da função calcular() é interrompida prematuramente através da instrução return.
Se o número fornecido pelo usuário for válido, o código prossegue para a lógica principal de identificação dos números pares. Três variáveis são inicializadas: contador (começando em zero, para contar quantos números pares são encontrados), numeroAtual (começando em 1, para iterar pelos números a partir de 1 até o limite) e paresEncontrados (um array vazio, que armazenará os números pares identificados).
O coração da busca pelos números pares reside em um laço while. Este laço continua executando enquanto o valor da variável numeroAtual for menor ou igual ao número limite (numero) fornecido pelo usuário. Dentro de cada iteração do laço, o código verifica se numeroAtual é um número par. Isso é feito utilizando o operador módulo (%). A expressão numeroAtual % 2 === 0 avalia se o resto da divisão de numeroAtual por 2 é exatamente igual a zero. Se for, significa que numeroAtual é divisível por 2 e, portanto, é um número par.
Quando um número par é identificado, duas ações ocorrem: a variável contador é incrementada em 1, e o número par (numeroAtual) é adicionado ao final do array paresEncontrados usando o método push(). Independentemente de o número ser par ou não, a variável numeroAtual é incrementada em 1 ao final de cada iteração do laço while, garantindo que o próximo número na sequência seja verificado na próxima passagem, e que o laço eventualmente termine quando numeroAtual ultrapassar o numero limite.
Após a conclusão do laço while, quando todos os números de 1 até o limite numero foram verificados, o código prepara a exibição dos resultados. A propriedade innerHTML da resultadoDiv é atualizada com uma string formatada contendo HTML. Essa string exibe uma mensagem indicando o limite superior da busca (numero), a quantidade total de números pares encontrados (contador) e a lista dos números pares encontrados (paresEncontrados), formatada como uma string separada por vírgulas usando o método join(", "). As informações de quantidade e a lista de números são destacadas usando a tag <strong> para negrito.
Finalmente, como última ação dentro da função calcular(), o valor do campo de entrada numeroInput é limpo (definido como uma string vazia ""), preparando o campo para uma nova entrada do usuário sem que ele precise apagar manualmente o valor anterior.
Em resumo, o script JavaScript implementa um processo interativo simples: recebe um número limite do usuário, valida essa entrada, itera de 1 até esse limite, identifica e coleta todos os números pares nesse intervalo, e por fim, apresenta um resumo claro dos resultados na página web, informando a quantidade e quais foram os números pares encontrados.